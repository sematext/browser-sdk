/* @flow */
import { ResourceTimingCompression } from 'resourcetiming-compression';
import pako from 'pako';
import { SESSION_COOKIE, SESSION_KEEP_ALIVE_MINUTES, USER_COOKIE, DEBUG_PARAM_KEY } from './constants';
import { ResourceType, resourceCategories } from './ResourceType';
import type { CommandContext, UrlInfo } from './commands/types';

declare var BUILD_NUMBER:string;
// eslint-disable-next-line camelcase
declare var __webpack_hash__:string;

const disabledResourceTypes = [
  // Don't collect the page load entry generated by resourcetiming-compression
  'html',
];

// eslint-disable-next-line
export const toUrlInfo = (url: string, resolveUrl: ?Function): UrlInfo => {
  const {
    protocol,
    hostname,
    port,
    pathname,
    search,
    hash,
  } = new URL(url);

  const urlObject = {
    protocol,
    hostname,
    port,
    pathname,
    search,
    hash,
  };
  if (resolveUrl) {
    const resolvedUrl = resolveUrl(urlObject);
    if (!resolvedUrl.pathname) {
      throw new Error('`pathname` cannot be empty');
    }
    return { ...urlObject, ...resolvedUrl };
  }
  return urlObject;
};

export const toAbsoluteUrl = (url: string): string => {
  const l = document.createElement('a');
  l.href = url;
  return l.href;
};

// eslint-disable-next-line camelcase
export const getScriptVersion = () => `${BUILD_NUMBER}:${__webpack_hash__}`;

export const getConnectionType = () => {
  const {
    navigator: {
      connection,
      mozConnection,
      webkitConnection,
    },
  } = window;
  const c = connection || mozConnection || webkitConnection;
  return c && c.effectiveType;
};

export const getDefaultMeta = (context: CommandContext, mergeTags: ?Object) => ({
  user: context.user ? ({
    ...context.user,
    tags: {
      ...context.user.tags,
      ...mergeTags,
    },
  }) : ({
    identifier: context.anonUserID,
    anonymous: true,
    tags: mergeTags,
  }),
  sessionID: context.sessionID,
  release: context.config && context.config.release,
  userAgent: context.scope.navigator.userAgent,
  connectionType: getConnectionType(),
  scriptVersion: getScriptVersion(),
  ...(context.scope.screen ? {
    screen: {
      height: context.scope.screen.height,
      width: context.scope.screen.width,
    },
  } : {}),
});

export const setCookie = (name: string, value: string, expiresMinutes: number) => {
  const d = new Date();
  d.setTime(d.getTime() + (60 * 1000 * expiresMinutes));
  document.cookie = `${name}=${value};path=/;expires=${d.toUTCString()}`;
};

export const getCookie = (name: string): ?string => {
  const v = document.cookie.match(`(^|;) ?${name}=([^;]*)(;|$)`);
  return v ? v[2] : null;
};

// Very compact uuid4 implementation: https://gist.github.com/jed/982883
/* eslint-disable */
//$FlowFixMe
export const uuid4 = (a): string => a?(a^Math.random()*16>>a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,uuid4)
/* eslint-enable */


/**
 * Sets up an interval to keep the session alive
 */
export const keepSessionAlive = (sessionID: string) => setInterval(() => {
  setCookie(SESSION_COOKIE, sessionID, SESSION_KEEP_ALIVE_MINUTES);
}, (SESSION_KEEP_ALIVE_MINUTES - 1) * 60 * 1000);

/**
 * Reads anonymous user ID from cookie or creates new cookie with user ID.
 *
 * User cookies should remain alive practically forever (100 years).
 */
export const getAnonUserID = (): string => {
  const cookieValue = getCookie(USER_COOKIE);

  if (!cookieValue) {
    const anonUserID = uuid4();
    setCookie(USER_COOKIE, anonUserID, 60 * 24 * 365 * 100 /* 10 years */);
    return anonUserID;
  }

  return cookieValue;
};


/**
 * Reads session ID from cookie or creates new cookie with session ID.
 *
 * Session cookies will remain alive for SESSION_KEEP_ALIVE_MINUTES between browser sessions.
 *
 * Returns session ID.
 */
export const getSessionID = (): string => {
  const cookieValue = getCookie(SESSION_COOKIE);

  if (!cookieValue) {
    const sessionID = uuid4();
    setCookie(SESSION_COOKIE, sessionID, SESSION_KEEP_ALIVE_MINUTES);
    return sessionID;
  }

  return cookieValue;
};

/**
 * Creates new command context.
 *
 * Use this when initializing rum script.
 */
export const setupContext = (name: string): CommandContext => {
  const sessionID = getSessionID();
  const anonUserID = getAnonUserID();

  const context: CommandContext = {
    config: null,
    uploader: null,
    user: null,
    scope: window,
    sessionID,
    anonUserID,
    name,
  };

  return context;
};

export const isDebugInParams = (): boolean => window.location.search.indexOf(DEBUG_PARAM_KEY) > -1;

export const logDebug = (...params: Array<any>) => {
  if (window.SCE_DEBUG || isDebugInParams()) {
    // eslint-disable-next-line no-console
    console.log(...params);
  }
};

export const byteCount = (resource: string): number => encodeURI(resource).split(/%..|./).length - 1;

export const getMaxRequestSize = () => {
  if (window.SCE_MAX_REQUEST_SIZE) {
    return window.SCE_MAX_REQUEST_SIZE;
  }
  // it should be less than 1MB
  return 1048576 - 100000;
};

export const getTime = () =>
  (Date.now && Date.now()) || (new Date().getTime());

export const getResourceType = (entry: any) => {
  if (['fetch', 'xmlhttprequest'].includes(entry.initiatorType)) {
    return resourceCategories.XHR.title;
  }

  const resolved = ResourceType.fromURL(entry.name);
  if (resolved) {
    return resolved.category().title;
  }

  return resourceCategories.Other.title;
};

export const stripHash = (originalUrl: string, urlResolver: ?Function = urlObj =>
  ({
    protocol: urlObj.protocol,
    hostname: urlObj.hostname,
    port: urlObj.port,
    pathname: urlObj.pathname,
    search: urlObj.search,
    hash: '',
  })): string => {
  const urlObject = toUrlInfo(originalUrl, urlResolver);
  const processedUrl = new URL(originalUrl);
  processedUrl.protocol = urlObject && urlObject.protocol;
  processedUrl.hostname = urlObject && urlObject.hostname;
  processedUrl.port = urlObject && urlObject.port;
  processedUrl.pathname = urlObject && urlObject.pathname ?
    urlObject.pathname : processedUrl.pathname;
  processedUrl.search = urlObject && urlObject.search ? urlObject.search : processedUrl.search;
  processedUrl.hash = urlObject && urlObject.hash ? urlObject.hash : processedUrl.hash;

  return processedUrl.href;
};

/**
 * Removes the error port that is sometimes passed from the.
 */
export const correctPort = (resourceName: string): string => resourceName.replace(':0/', '/');

/**
 * Return resources data as zlib compressed json.
 */
export const getCompressedResources = (
  win: any, from: ?number, to: ?number,
  urlResolver: ?Function,
) => {
  // we previously used resourcetiming-compression to both read and compress
  // the resources due to lack of libraries that can decompress this info in
  // other languages we use zlib for compressions instead and use
  // resourcetiming-compression for reading the resource entries
  const resources = ResourceTimingCompression.getFilteredResourceTiming(win, from, to);

  // filter out "data:" base64 encoded resources
  // see https://sematext.atlassian.net/browse/SC-6210
  // filter out resource types that we don't want to collect
  resources.entries = resources.entries.filter(e =>
    !e.name.startsWith('data:') && disabledResourceTypes.indexOf(e.initiatorType) === -1
    && !e.name.includes('rum-receiver'));

  // attach resource type
  resources.entries = resources.entries.map(r => ({
    ...r,
    name: correctPort(stripHash(r.name, urlResolver)),
    resourceType: getResourceType(r),
  }));

  const data = JSON.stringify(resources);
  const deflated = pako.deflate(data, { to: 'string' });
  const encoded = btoa(deflated);
  return `ZLIB${encoded}`;
};
